# Netcat implemetation in python
# Author: Mose
# Date: 5 Apr 2022

import sys
import argparse
import socket
import subprocess
import threading

#global variables
listen = False
command = False
upload = False
execute = ""
upload_destination = ""
target = ""
port = ""

def client_sender(buffer):

    client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    try:
        client.connect((target, port))

        if len(buffer):
            client.send(buffer.encode())

        while True:
            recv_len = 1
            response = ""

            while recv_len:

                data = client.recv(4096)
                recv_len += len(data)
                response += data

                if recv_len < 4096:
                    break
            
            print(response)

            # send data
            buffer = raw_input("")
            buffer +=  "\n"

            client.send(buffer.encode())
    except:
        print("Exception exiting")

        #close client
        client.close()

def server_loop():
    global target

    if not len(target):
        target = "0.0.0.0"
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server.bind((target,port))
    server.listen(5)

    while True:

        client_socket , addr = server.accept()
        # create thread
        client_thread = threading.Thread(target=client_handler, args=(client_socket,))
        client_thread.start()

def run_command(command):
    # Run commands using subprocess module

    # strip newline
    command = command.rstrip()

    # run the command and get output back
    try:
        output = subprocess.check_output(command, stderr=subprocess.STDOUT, shell=True)
    except:
        output = "Failed to execute command.\r\n"
    
    # send to client
    return output

def client_handler(client_socket):
    global upload
    global execute
    global command

    # check for upload

    if len(upload_destination):
        file_buffer = ""

        while True:
            data = client_socket.read(1024)

            if not data:
                break
            file_buffer += data
        
        # write to file
        try:
            file_descriptor = open(upload_destination, 'wb')
            file_descriptor.write(buffer)
            file_descriptor.close()

            #sucess message
            client_socket.send("File sucessfuly saved to -> {}".format(upload_destination).encode())
        except:
            client_socket.send("Failed to save file to -> {}".format(upload_destination).encode())

    if len(execute):
        # run command
        output = run_command(execute)

        client_socket.send(output.encode())

    if command:

        while True:

            client_socket.send("BHP:#>".encode())
            
            #receive data
            cmd_buffer = ""
            while "\n" not in cmd_buffer:
                cmd_buffer += client_socket.recv(1024)

            # data response
            response = run_command(cmd_buffer)

            #send back response
            client_socket.send(response.encode())

def main():
    # Program entry point uses argaparse
    # to capture user input 
    parse = argparse.ArgumentParser(description="Program that replaces netcat in most systems")
    parse.add_argument('-t','--target', help='Host machine')
    parse.add_argument('-l', '--listen', help='Listen on host:port for incoming connections')
    parse.add_argument('-u', '--upload', help='On connection receive and write file to disk')
    parse.add_argument('-c', '--commandshell', help='Run command')
    parse.add_argument('-p', '--port', help='port to use')
    parse.add_argument('-e', '--execute', help='execute a file/command')
    parse.add_argument('-up', '--upload_destination', help='Name and path of the file')
    args = parse.parse_args()

    global target 
    global upload_destination
    global execute
    global port
    global command
    global upload 
    global listen 

    target = args.target
    listen = args.listen
    upload = args.upload
    command = args.commandshell
    port = args.port
    execute = args.execute
    upload_destination = args.upload_destination

    if not listen and len(target) and port > 0:
        # get data from stdin i.e command line
        # this will block use crtl + D if not getting data from command line
        buffer = sys.stdin.read()

        #send data off
        client_sender(buffer)
    
    if parse.listen:
        # start server loop 
        server_loop()

if __name__ == "__main__":
    main()
